# Macro 命令列表

鼠标存储 macro(宏/巨集，以下统称「宏」) 是在 Flash 存储器中存储的， [基本信息](./basic.md) 中的 Flash 存储器管理机制 一节中有详尽描述。

鼠标存储的宏和 profile 是独立的，是全局存储的，不属于某一个 profile。每个宏有一个2字节长的 ID，并且有描述和内容，描述是雷蛇软件用来存储宏的 UUID、名字等信息的，自己实现的时候可以不用设置，只用设置2字节长的 ID 和内容就行了。

## get_macro_count

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x0680 | -      | 0            | 2            |

获取宏的总数，2字节的数据参数即为数量。

## get_macro_list

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x068b | -      | 2            | 2(count)+2*32 |

获取所有宏的 ID，每个宏的 ID 占2字节，该命令一次可以读取 32 个 ID。读取参数是开始序号，传入该参数就会从指定位置开始读取。count 是总的数量，不是这次返回的数量。

如果宏多于32个，就要分好多次读取，每次读32个，把读取参数加32再读一遍，直到读完。

## get_macro_info

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x068c | 0x060c | 2(id)+2(start) | 2(length)+64(data) |

获取指定 ID 宏的描述，就是雷蛇软件用来储存宏的 UUID、名称等的。这个对功能不产生实际影响。里面的格式我没有详细分析。

读取参数和数据参数和 `get_macro_list` 类似。每次最多读取64个字节，然后再增加 start 参数。

## delete_macro

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| -      | 0x0603 | 2(id)        | 0            |

删除指定 ID 的宏，删除了以后，原本占用的空间会变成 recycled。

## get_macro_size

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x0688 | 0x0608 | 2(id)        | 4            |

获取或者设置指定 macro 的大小，单位是字节。在新创建 macro 的时候，先要使用这个函数开辟存储空间，然后才能写入内容。也可以用来读取 macro 内容时获取它的大小。

## get_macro_function

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x0689 | 0x0609 | 2(id)+4(start)+1(length) | length(data) |

设置或读取宏的内容，宏的内容数据就是一个字节串，编码的是宏的所有操作，编码方式下文有写。读取参数：

- id: 要操作的宏 ID，如果是写入，那这个宏必须是新创建的，而且使用 `set_macro_size` 开辟空间了
- start: 开始写入的位置
- length: 后面的数据长度

数据参数长度是 length，可以设置成64，也就是每次写入（或读取） 64 字节。然后每次读取或写入完了以后增加 start，就可以继续读取或写入后面的内容了。

## 宏的内容数据

这里介绍雷蛇板载内存上宏的编码方式，可以使用 `get_macro_function` 写入。

首先，宏的内容包含了若干个操作，每个操作编码所占的字节数不是固定的，但是可以从前往后依次划分每个操作，多个操作连接到一起就是一个宏。操作有键盘、鼠标、延时等，具体定义如下：

**键盘按键（2字节长）**：

- 1字节 0x01 表示键盘按下；0x02 表示键盘松开
- 1字节 HID 按键码，详见按键功能绑定的文档

**系统电源控制（2字节长）**：

- 1字节 0x03 或 0x04，功能相同
- 1字节 按键值，详见按键功能绑定的文档，与按键绑定的定义相同

如果要按下松开的话，必须要先加一个操作，值设为要按的按钮（按下），然后再加一个值设为0的（松开），否则它会一直按住。

**Consumer（3字节长）**：

- 1字节 0x05 或 0x06，功能相同
- 2字节 按键值，详见按键功能绑定的文档，与按键绑定的定义相同

按下松开的注意事项，和上一个一样

**鼠标按键（2字节长）**：

- 1字节 0x08，表示是鼠标按键
- 1字节 按键值

这里的按键值，和按键功能绑定的不一样，如下表，每一位代表一个按键，可以组合：

| 按键值 | 按键 |
| ------ | ------ |
| 0x01 | 左键 |
| 0x02 | 右键 |
| 0x04 | 中键 |
| 0x08 | 后退键 |
| 0x10 | 前进键 |

鼠标按键的操作，按下以后后面必须要有个松开的操作，不然宏触发完以后，那个按钮就会保持按下。例如：

左键按下再立刻松开

08 01 08 00

左键按下、右键按下、左键松开、右键松开

08 01 08 03 08 02 08 00

**鼠标滚轮（2字节长）**：

- 1字节 0x0a，表示是鼠标滚轮
- 1字节 位移值

位移值是有符号数，表示鼠标滚轮滚动的格数，向上是 01，向下是 ff

**延时（2字节长）**：

- 1字节 0x11，1个字节长的延时
- 1字节 延时长度

延时长度的单位是毫秒，256ms以内的短延时可以用这个，省1字节空间

**延时（3字节长）**：

- 1字节 0x12，2个字节长的延时
- 2字节 延时长度

延时长度的单位是毫秒，最大65535ms


