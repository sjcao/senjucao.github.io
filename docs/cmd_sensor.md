# 传感器命令列表

传感器命令就是控制鼠标光学传感器抬升距离、校准设置等。雷蛇雷云程序里面还有鼠标垫校准的功能，也包括在其中。

雷蛇的软件里面大体有几种设置

- 首先是禁用校准，使用固定的抬升距离
- 其次是使用雷蛇官方的鼠标垫校准信息
- 最后是自己执行鼠标垫校准

负责这些设置的命令如下：

## get_sensor_state

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x0b83 | 0x0b03 | 2(0x0004)    | 1            |

是否使用校准设置，如果数据参数是0，则使用固定抬升距离，是1则使用鼠标垫校准

读取参数长度为固定的 0x0004（下同），含义我不清楚，就这样设置就可以了。

## set_sensor_calibration

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| -      | 0x0b09 | 2(0x0004)    | 2            |

使鼠标进入自行校准模式或退出自行校准模式。

进入自行校准模式的方式：

- 用 `set_device_mode` 将鼠标调整为驱动模式
- `set_sensor_state` 启用鼠标垫校准
- `set_sensor_lift` 设置为 calib1
- 发送此命令，数据参数为 0

鼠标 endpoint 2 id 5 应该会发出 050a00，表示校准开始

进入以后，鼠标指针会停止移动，在鼠标垫上移动比较长的距离，基本把鼠标垫都覆盖了以后，再使用以下方式退出自行校准模式：

- 发送此命令，数据参数为 1

鼠标 endpoint 2 id 5 应该会发出 050a01，表示校准成功，或050a02，表示校准失败（运动的距离太短，或者没挨着鼠标垫）

校准完了以后，获取的原校准数据，使用 `get_sensor_lift_config` 获取，一共有4字节有用内容，类似 26 03 30 03

校准完了以后，鼠标并没有配置好，还需要使用获取的原校准数据计算出要写入的校准计算值，再写回鼠标。这个数据的含义，还有怎么计算，在后面会写到。

## get_sensor_lift

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x0b8b | 0x0b0b | 2(0x0004)    | 2            |

这个是设置鼠标使用固定抬升距离，还是使用校准信息的，具体使用哪种。数据参数有以下的值：

| 值 | 含义 | 对应 sensor_state |
| ------ | ------ | ------ |
| 0x0000 | 不使用任何设置（含义不太清楚） | 0 |
| 0x0100 | 对称 1mm | 0 |
| 0x0101 | 对称 2mm | 0 |
| 0x0102 | 对称 3mm | 0 |
| 0x0200 | 非对称 1-2mm | 0 |
| 0x0201 | 非对称 1-3mm | 0 |
| 0x0202 | 非对称 2-3mm | 0 |
| 0x0300 | 对称雷蛇校准 | 1 |
| 0x0400 | 非对称雷蛇校准 | 1 |
| 0x0500 | 对称自行校准 | 1 |
| 0x0600 | 非对称自行校准 | 1 |

## get_sensor_lift_config

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x0b85 | 0x0b05 | 2(0x0004)    | 8            |

该命令的读和写操作功能不一样。读操作是获取校准结果，详见上面的校准过程。

写操作是和 `get_sensor_lift` 的 0x0300 和 0x0500 两个对称校准方案一起用的，是写入那两个对称校准方案采用的校准计算值。

要使用对称校准方案，先要用算法把校准数据和 lift 值一起计算出校准计算值，使用该命令写入，然后还需要使用 `set_sensor_lift` 和 `set_sensor_state` 设置对应的值。

## get_sensor_lift_config_a

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x0b8d | 0x0b0d | 2(0x0004)    | 8            |

该命令用来写入或读取非对称校准计算值A，需要和 `get_sensor_lift` 的 0x0400 和 0x0600 两个非对称校准设置用。具体啥是「非对称校准计算值A」，下面有写。

## get_sensor_lift_config_b

| 读命令 | 写命令 | 读取参数长度 | 数据参数长度 |
| ------ | ------ | ------------ | ------------ |
| 0x0b8c | 0x0b0c | 2(0x0004)    | 5            |

该命令用来写入或读取非对称校准计算值B，需要和 `get_sensor_lift` 的 0x0400 和 0x0600 两个非对称校准设置用。具体啥是「非对称校准计算值B」，下面有写。

## 如果要使用固定的抬升距离

对照 `get_sensor_lift` 中的表格，用 `set_sensor_lift` 和 `set_sensor_state` 设置好需要的值就可以了。

## 如果要使用雷蛇官方的鼠标垫校准信息

经过我的实验，雷蛇自带的所有鼠标垫校准，其给鼠标传输的信息都是完全一样的，也就是说，雷蛇雷云里面那么多鼠标垫，看似每个鼠标垫都经过精心校准，其实应用了以后都是一个效果。

首先，不管是雷蛇校准还是自行校准，其中都涉及到了一个算法：

- 用获取的原校准数据
- 再加上 lift 和 land 两个值
  - lift 表示抬升距离，land 表示降落距离，两个取值范围1-10，都是相对值
  - 非对称是两个值，如果是对称的话，就只有一个值
  - 这两个值就是雷云软件里面那个1-10的滑动条
- 计算出要写入的校准计算值
  - 如果是非对称，是两个值，长8字节的A和长5字节的B；对称则是1个长8字节的值

原校准数据获取方法是上面 `set_sensor_calibration` 描述的。这个算法经过我的分析和逆向，用 python 代码表示如下：

- 输入的 `mouse_data` 是4字节的从鼠标获取的原校准数据
- `land=None` 代表对称，将 `land` 设置为数字则为非对称

```python

def calculate_lift_config(mouse_data, lift, land=None):
    if not (1 <= lift <= 10) or not (land is None or 1 <= land <= 10):
        raise ValueError('lift and land must be within 1 and 10')
    asym = land is not None
    def calc0(l, m0):
        return round(m0 - (m0 - 8) / 10 * (l-1))
    def calc2(l, m1, m3):
        return (l-1) * m3 + m1
    m0, m1, m2, m3 = mouse_data
    
    a0 = calc0(lift, m0)
    if lift < 5: a1 = m2
    else:        a1 = [0,0,0,0,0x30,0x30,0x38,0x38,0x38,0x38][lift-1]
    a2 = calc2(lift, m1, m3)
    a3 = 0x88 if asym else 0x08
    a4 = max(10, a2)
    if asym: a5 = [0x5,0xf,0xf,0xf,0xf,0xf,0x0,0x0,0x0,0x0][lift-1]
    else:    a5 = [0x5,0x5,0x5,0x5,0x5,0x5,0x0,0x0,0x0,0x0][lift-1]
    a6 = [0x10,0xf,0xf,0xf,0xf,0xf,0xf,0xe,0xe,0xe,0xe][lift]
    a7 = [0xf,0xd,0xa,0xa,0xa,0x8,0x8,0x8,0x8,0x8][lift-1]
    a = bytes([a0, a1, a2, a3, a4, a5, a6, a7])
    if not asym:
        return a
    
    b0 = calc0(land, m0)
    if lift < 5: b1 = m2
    else:        b1 = [0,0,0,0,0x30,0x30,0x38,0x38,0x38,0x38][land-1]
    b2 = calc2(land, m1, m3)
    b3 = max(10, b2)
    b4 = [0xf,0xd,0xa,0xa,0xa,0x8,0x8,0x8,0x8,0x8][land-1]
    b = bytes([b0, b1, b2, b3, b4])
    return a, b
    
```

这个8字节参数或A、B参数的含义目前还不清楚。但是雷云软件就是这样计算的。

然后，雷蛇官方的鼠标垫原校准信息均相当于 `30 0d 20 02`，用这个数值和算法，加上 lift 和 land 值，计算出的数据就可以给 `set_sensor_lift_config` 或 `_a`, `_b` 的版本了，同时也要设置 `sensor_lift` 和对应的 `sensor_state`。

## 如果要使用自行校准信息

首先，先使用上面的命令，校准鼠标垫，获取原校准数据。

然后，运行上面的算法算出，按相同的方法设置校准计算值。

同时，也要设置 `sensor_lift` 和对应的 `sensor_state`

校准时，如果鼠标距离鼠标垫远，则原校准数据第1字节会较小。其余3个字节我测试一直都是 03 30 03。目前含义不清楚，但是雷云软件就是这样计算的，我也不知道原理，网上也没有这款传感器 PAW3399 的数据手册。
